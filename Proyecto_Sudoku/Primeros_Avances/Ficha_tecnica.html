<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentaci√≥n T√©cnica - Solucionador Avanzado de Sudoku</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .nav-tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 2px solid #ecf0f1;
            overflow-x: auto;
        }
        
        .nav-tab {
            padding: 12px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1em;
            font-weight: 600;
            color: #7f8c8d;
            white-space: nowrap;
            transition: all 0.3s ease;
            border-radius: 8px 8px 0 0;
        }
        
        .nav-tab:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }
        
        .nav-tab.active {
            background: #667eea;
            color: white;
            box-shadow: 0 -2px 10px rgba(102, 126, 234, 0.3);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .section {
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border-left: 5px solid #667eea;
        }
        
        .section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4em;
            display: flex;
            align-items: center;
        }
        
        .section h4 {
            color: #34495e;
            margin: 20px 0 10px 0;
            font-size: 1.2em;
        }
        
        .method-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
            border-left: 4px solid #3498db;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .method-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }
        
        .method-name {
            font-weight: bold;
            color: #2980b9;
            font-size: 1.1em;
            margin-bottom: 8px;
        }
        
        .method-params {
            background: #ecf0f1;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin: 8px 0;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin: 15px 0;
            overflow-x: auto;
            line-height: 1.4;
        }
        
        .flow-diagram {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .flow-step {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 25px;
            margin: 10px;
            border-radius: 25px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            transition: transform 0.2s ease;
        }
        
        .flow-step:hover {
            transform: scale(1.05);
        }
        
        .arrow {
            font-size: 1.5em;
            color: #667eea;
            margin: 0 10px;
        }
        
        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
        }
        
        .complexity-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        .complexity-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .complexity-table tr:hover {
            background: #f8f9fa;
        }
        
        .icon {
            margin-right: 10px;
            font-size: 1.2em;
        }
        
        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
        
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            color: #0c5460;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
        }
        
        .collapsible:hover {
            color: #667eea;
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .collapsible-content.active {
            max-height: 1000px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß© Solucionador Avanzado de Sudoku</h1>
            <p>Documentaci√≥n T√©cnica Completa del Sistema de Resoluci√≥n Inteligente</p>
        </div>
        
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('overview')">üìã Resumen</button>
            <button class="nav-tab" onclick="showTab('architecture')">üèóÔ∏è Arquitectura</button>
            <button class="nav-tab" onclick="showTab('methods')">‚öôÔ∏è M√©todos</button>
            <button class="nav-tab" onclick="showTab('algorithms')">üß† Algoritmos</button>
            <button class="nav-tab" onclick="showTab('flow')">üîÑ Flujo</button>
            <button class="nav-tab" onclick="showTab('usage')">üíª Uso</button>
        </div>
        
        <div id="overview" class="tab-content active">
            <div class="section">
                <h3><span class="icon">üìñ</span>Descripci√≥n General</h3>
                <p>El <span class="highlight">AdvancedSudokuSolver</span> es un sistema inteligente de resoluci√≥n de Sudoku que combina m√∫ltiples t√©cnicas l√≥gicas avanzadas con backtracking optimizado. Implementa estrategias usadas por solucionadores humanos expertos antes de recurrir a fuerza bruta.</p>
                
                <div class="info">
                    <strong>üéØ Objetivo Principal:</strong> Resolver puzzles de Sudoku utilizando primero l√≥gica pura (como lo har√≠a un humano experto) y solo recurrir a backtracking cuando sea absolutamente necesario.
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">‚ú®</span>Caracter√≠sticas Principales</h3>
                <div class="method-card">
                    <div class="method-name">üîç T√©cnicas L√≥gicas Avanzadas</div>
                    <p>Implementa 4 t√©cnicas principales: Naked Singles, Hidden Singles, Naked Pairs y Pointing Pairs</p>
                </div>
                <div class="method-card">
                    <div class="method-name">üß† Backtracking Inteligente</div>
                    <p>Utiliza la heur√≠stica MRV (Minimum Remaining Values) para optimizar la b√∫squeda</p>
                </div>
                <div class="method-card">
                    <div class="method-name">üìä Sistema de Candidatos</div>
                    <p>Mantiene y actualiza din√°micamente los n√∫meros posibles para cada celda vac√≠a</p>
                </div>
                <div class="method-card">
                    <div class="method-name">üéÆ Interfaz de Depuraci√≥n</div>
                    <p>Proporciona informaci√≥n detallada del proceso de resoluci√≥n paso a paso</p>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">‚ö°</span>Complejidad y Rendimiento</h3>
                <table class="complexity-table">
                    <tr>
                        <th>Aspecto</th>
                        <th>Complejidad</th>
                        <th>Descripci√≥n</th>
                    </tr>
                    <tr>
                        <td>T√©cnicas L√≥gicas</td>
                        <td>O(n¬≤) por iteraci√≥n</td>
                        <td>Muy eficiente para la mayor√≠a de puzzles</td>
                    </tr>
                    <tr>
                        <td>Backtracking</td>
                        <td>O(9^(celdas_vac√≠as))</td>
                        <td>Optimizado con MRV y poda temprana</td>
                    </tr>
                    <tr>
                        <td>Memoria</td>
                        <td>O(n¬≤)</td>
                        <td>Almacena grid + candidatos</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <div id="architecture" class="tab-content">
            <div class="section">
                <h3><span class="icon">üèóÔ∏è</span>Estructura de la Clase</h3>
                
                <h4>Propiedades Principales</h4>
                <div class="method-card">
                    <div class="method-name">self.size = 9</div>
                    <p>Tama√±o del grid de Sudoku (9x9)</p>
                </div>
                <div class="method-card">
                    <div class="method-name">self.box_size = 3</div>
                    <p>Tama√±o de cada caja/subcuadr√≠cula (3x3)</p>
                </div>
                <div class="method-card">
                    <div class="method-name">self.grid</div>
                    <p>Matriz NumPy 9x9 que representa el estado actual del Sudoku</p>
                </div>
                <div class="method-card">
                    <div class="method-name">self.candidates</div>
                    <p>Diccionario que mapea posiciones (row, col) a sets de n√∫meros posibles</p>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">üîß</span>M√©todos de Utilidad</h3>
                
                <div class="method-card">
                    <div class="method-name">get_candidates(row, col)</div>
                    <div class="method-params">Par√°metros: int row, int col ‚Üí set</div>
                    <p>Calcula y retorna el conjunto de n√∫meros v√°lidos para una celda espec√≠fica bas√°ndose en las reglas del Sudoku.</p>
                </div>
                
                <div class="method-card">
                    <div class="method-name">update_all_candidates()</div>
                    <div class="method-params">Par√°metros: None ‚Üí None</div>
                    <p>Recalcula completamente la matriz de candidatos para todas las celdas vac√≠as del grid.</p>
                </div>
                
                <div class="method-card">
                    <div class="method-name">update_candidates_after_placement(row, col, num)</div>
                    <div class="method-params">Par√°metros: int row, int col, int num ‚Üí None</div>
                    <p>Actualiza eficientemente los candidatos despu√©s de colocar un n√∫mero, elimin√°ndolo de fila, columna y caja correspondientes.</p>
                </div>
            </div>
        </div>
        
        <div id="methods" class="tab-content">
            <div class="section">
                <h3><span class="icon">üéØ</span>M√©todos de Resoluci√≥n Principales</h3>
                
                <div class="method-card">
                    <div class="method-name">solve(grid)</div>
                    <div class="method-params">Par√°metros: numpy.array grid ‚Üí bool</div>
                    <p><strong>M√©todo Principal:</strong> Coordina todo el proceso de resoluci√≥n. Primero aplica t√©cnicas l√≥gicas y luego backtracking si es necesario.</p>
                    <div class="code-block">
def solve(self, grid):
    self.grid = grid.copy()
    # 1. Intentar resolver con l√≥gica pura
    if self.solve_with_logic():
        return True
    # 2. Si queda algo, usar backtracking
    return self.solve_with_backtrack()
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">solve_with_logic()</div>
                    <div class="method-params">Par√°metros: None ‚Üí bool</div>
                    <p>Aplica iterativamente todas las t√©cnicas l√≥gicas hasta que no se pueda hacer m√°s progreso.</p>
                </div>
                
                <div class="method-card">
                    <div class="method-name">solve_with_backtrack()</div>
                    <div class="method-params">Par√°metros: None ‚Üí bool</div>
                    <p>Sistema de backtracking optimizado que usa la heur√≠stica MRV para seleccionar la pr√≥xima celda a llenar.</p>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">üñ®Ô∏è</span>M√©todos de Visualizaci√≥n</h3>
                
                <div class="method-card">
                    <div class="method-name">print_grid(grid=None)</div>
                    <div class="method-params">Par√°metros: numpy.array grid (opcional) ‚Üí None</div>
                    <p>Imprime el Sudoku en formato legible con separadores para las cajas 3x3.</p>
                </div>
                
                <div class="method-card">
                    <div class="method-name">print_candidates()</div>
                    <div class="method-params">Par√°metros: None ‚Üí None</div>
                    <p>Muestra todos los candidatos restantes para depuraci√≥n, √∫til para entender el estado interno.</p>
                </div>
            </div>
        </div>
        
        <div id="algorithms" class="tab-content">
            <div class="section">
                <h3><span class="icon">üß†</span>T√©cnicas L√≥gicas Implementadas</h3>
                
                <div class="method-card">
                    <div class="method-name">1. Naked Singles (N√∫meros Desnudos)</div>
                    <p><strong>Concepto:</strong> Si una celda solo tiene un candidato posible, ese debe ser el n√∫mero correcto.</p>
                    <div class="info">
                        <strong>Implementaci√≥n:</strong> Recorre todas las celdas con candidatos y llena aquellas que solo tienen una opci√≥n.
                    </div>
                    <div class="code-block">
# Ejemplo: Si una celda solo puede ser 7
if len(candidates) == 1:
    place_number(position, candidates[0])
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">2. Hidden Singles (N√∫meros Ocultos)</div>
                    <p><strong>Concepto:</strong> Si un n√∫mero solo puede ir en una posici√≥n dentro de una fila, columna o caja, debe ir ah√≠.</p>
                    <div class="info">
                        <strong>Implementaci√≥n:</strong> Para cada n√∫mero (1-9), verifica si solo hay una posici√≥n v√°lida en cada regi√≥n.
                    </div>
                    <div class="code-block">
# Ejemplo: Si el 5 solo puede ir en una celda de la fila
for number in range(1, 10):
    possible_positions = find_positions_in_row(number)
    if len(possible_positions) == 1:
        place_number(possible_positions[0], number)
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">3. Naked Pairs (Parejas Desnudas)</div>
                    <p><strong>Concepto:</strong> Si dos celdas en la misma regi√≥n solo pueden contener los mismos dos n√∫meros, esos n√∫meros no pueden aparecer en otras celdas de esa regi√≥n.</p>
                    <div class="warning">
                        <strong>Complejidad:</strong> Esta t√©cnica requiere comparar m√∫ltiples celdas y puede ser computacionalmente m√°s costosa.
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">4. Pointing Pairs (Parejas Apuntadas)</div>
                    <p><strong>Concepto:</strong> Si un candidato en una caja solo aparece en una fila o columna, puede eliminarse de esa fila/columna fuera de la caja.</p>
                    <div class="info">
                        <strong>Aplicaci√≥n:</strong> Muy efectiva para reducir candidatos en puzzles complejos.
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">üîç</span>Algoritmo de Backtracking</h3>
                
                <div class="method-card">
                    <div class="method-name">Heur√≠stica MRV (Minimum Remaining Values)</div>
                    <p>Selecciona la celda con menor n√∫mero de candidatos posibles para intentar llenar primero.</p>
                    <div class="code-block">
# Encuentra la celda con menos opciones
min_candidates = min(len(cands) for cands in candidates.values())
target_cell = find_cell_with_candidates(min_candidates)
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">Propagaci√≥n de Restricciones</div>
                    <p>Despu√©s de cada colocaci√≥n, actualiza inmediatamente todos los candidatos afectados para detectar inconsistencias temprano.</p>
                </div>
                
                <div class="method-card">
                    <div class="method-name">Poda Temprana</div>
                    <p>Si cualquier celda queda sin candidatos v√°lidos, inmediatamente hace backtrack sin explorar m√°s.</p>
                </div>
            </div>
        </div>
        
        <div id="flow" class="tab-content">
            <div class="section">
                <h3><span class="icon">üîÑ</span>Flujo de Ejecuci√≥n</h3>
                
                <div class="flow-diagram">
                    <div class="flow-step">Inicializaci√≥n</div>
                    <span class="arrow">‚Üí</span>
                    <div class="flow-step">C√°lculo de Candidatos</div>
                    <span class="arrow">‚Üí</span>
                    <div class="flow-step">T√©cnicas L√≥gicas</div>
                    <br><br>
                    <span class="arrow">‚Üì</span>
                    <br>
                    <div class="flow-step">¬øResuelto?</div>
                    <span class="arrow">‚Üí</span>
                    <div class="flow-step">Backtracking MRV</div>
                    <span class="arrow">‚Üí</span>
                    <div class="flow-step">Soluci√≥n</div>
                </div>
            </div>
            
            <div class="section">
                <h3 class="collapsible" onclick="toggleCollapsible(this)"><span class="icon">üìù</span>Algoritmo Detallado ‚ñº</h3>
                <div class="collapsible-content">
                    <div class="code-block">
1. INICIALIZACI√ìN
   - Copiar grid de entrada
   - Calcular candidatos iniciales para todas las celdas vac√≠as

2. FASE L√ìGICA (iterativa hasta no haber progreso)
   a. Aplicar Naked Singles
   b. Aplicar Hidden Singles  
   c. Aplicar Naked Pairs
   d. Aplicar Pointing Pairs
   e. Limpiar candidatos vac√≠os
   f. ¬øHay progreso? ‚Üí continuar, sino ‚Üí fase 3

3. VERIFICACI√ìN
   - ¬øGrid completo? ‚Üí √âXITO
   - ¬øCandidatos restantes? ‚Üí fase 4

4. FASE BACKTRACKING
   a. Seleccionar celda con menos candidatos (MRV)
   b. Para cada candidato posible:
      - Guardar estado actual
      - Colocar n√∫mero y actualizar candidatos
      - ¬øEstado v√°lido? ‚Üí recursi√≥n
      - ¬ø√âxito? ‚Üí √âXITO
      - Sino ‚Üí restaurar estado y probar siguiente
   c. ¬øTodos los candidatos fallaron? ‚Üí FALLO
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">‚è±Ô∏è</span>Orden de Aplicaci√≥n de T√©cnicas</h3>
                <p>Las t√©cnicas se aplican en orden de <span class="highlight">eficiencia computacional</span> y <span class="highlight">efectividad</span>:</p>
                
                <table class="complexity-table">
                    <tr>
                        <th>Orden</th>
                        <th>T√©cnica</th>
                        <th>Complejidad</th>
                        <th>Efectividad</th>
                    </tr>
                    <tr>
                        <td>1¬∞</td>
                        <td>Naked Singles</td>
                        <td>O(n¬≤)</td>
                        <td>Alta - R√°pida</td>
                    </tr>
                    <tr>
                        <td>2¬∞</td>
                        <td>Hidden Singles</td>
                        <td>O(n¬≥)</td>
                        <td>Alta - Fundamental</td>
                    </tr>
                    <tr>
                        <td>3¬∞</td>
                        <td>Naked Pairs</td>
                        <td>O(n‚Å¥)</td>
                        <td>Media - Espec√≠fica</td>
                    </tr>
                    <tr>
                        <td>4¬∞</td>
                        <td>Pointing Pairs</td>
                        <td>O(n¬≥)</td>
                        <td>Media - Intersecciones</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <div id="usage" class="tab-content">
            <div class="section">
                <h3><span class="icon">üíª</span>Ejemplo de Uso</h3>
                
                <div class="code-block">
import numpy as np

# Crear una instancia del solucionador
solver = AdvancedSudokuSolver()

# Definir un puzzle (0 representa celdas vac√≠as)
puzzle = np.array([
    [5, 3, 0, 0, 7, 0, 0, 0, 0],
    [6, 0, 0, 1, 9, 5, 0, 0, 0],
    [0, 9, 8, 0, 0, 0, 0, 6, 0],
    [8, 0, 0, 0, 6, 0, 0, 0, 3],
    [4, 0, 0, 8, 0, 3, 0, 0, 1],
    [7, 0, 0, 0, 2, 0, 0, 0, 6],
    [0, 6, 0, 0, 0, 0, 2, 8, 0],
    [0, 0, 0, 4, 1, 9, 0, 0, 5],
    [0, 0, 0, 0, 8, 0, 0, 7, 9]
])

# Resolver el puzzle
if solver.solve(puzzle):
    print("¬°Puzzle resuelto exitosamente!")
    solver.print_grid()
else:
    print("No se pudo resolver el puzzle")
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">üîß</span>Par√°metros de Configuraci√≥n</h3>
                
                <div class="method-card">
                    <div class="method-name">Modificaciones Posibles</div>
                    <p>El c√≥digo est√° dise√±ado para ser extensible:</p>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li>Agregar nuevas t√©cnicas l√≥gicas (Hidden Pairs, X-Wing, etc.)</li>
                        <li>Modificar el orden de aplicaci√≥n de t√©cnicas</li>
                        <li>Ajustar la heur√≠stica de backtracking</li>
                        <li>Agregar m√©tricas de rendimiento</li>
                    </ul>
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">üìä</span>Salida del Sistema</h3>
                
                <div class="info">
                    El solver proporciona informaci√≥n detallada durante la ejecuci√≥n:
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Progreso por iteraci√≥n:</strong> Qu√© t√©cnicas se aplicaron</li>
                        <li><strong>N√∫mero de celdas restantes:</strong> Antes del backtracking</li>
                        <li><strong>Estado final:</strong> √âxito o fallo en la resoluci√≥n</li>
                    </ul>
                </div>
                
                <div class="code-block">
Resolviendo con t√©cnicas l√≥gicas...
Iteraci√≥n 1
  ‚úì N√∫meros desnudos aplicados
  ‚úì N√∫meros ocultos aplicados
Iteraci√≥n 2
  ‚úì Parejas desnudas aplicadas
T√©cnicas l√≥gicas completadas en 2 iteraciones
Quedan 12 celdas por resolver
Aplicando backtracking inteligente...
¬°Resuelto con backtracking!
                </div>
            </div>
            
            <div class="section">
                <h3><span class="icon">‚ö†Ô∏è</span>Consideraciones de Rendimiento</h3>
                
                <div class="warning">
                    <strong>Puzzles Muy Dif√≠ciles:</strong> En casos extremos donde las t√©cnicas l√≥gicas resuelven pocas celdas, el backtracking puede tomar tiempo exponencial.
                </div>
                
                <div class="method-card">
                    <div class="method-name">Optimizaciones Implementadas</div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Heur√≠stica MRV:</strong> Reduce dram√°ticamente el espacio de b√∫squeda</li>
                        <li><strong>Propagaci√≥n Inmediata:</strong> Detecta inconsistencias temprano</li>
                        <li><strong>Orden de T√©cnicas:</strong> Aplica primero las m√°s eficientes</li>
                        <li><strong>Limpieza de Candidatos:</strong> Elimina sets vac√≠os para evitar errores</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- Nueva secci√≥n: An√°lisis T√©cnico Detallado -->
        <div class="section" style="margin-top: 40px; border-left: 5px solid #e74c3c;">
            <h3><span class="icon">üî¨</span>An√°lisis T√©cnico Profundo</h3>
            
            <div class="section">
                <h4>üèóÔ∏è Patrones de Dise√±o Utilizados</h4>
                
                <div class="method-card">
                    <div class="method-name">Strategy Pattern (Patr√≥n Estrategia)</div>
                    <p>Cada t√©cnica l√≥gica es una estrategia independiente que puede aplicarse o no seg√∫n el estado del puzzle.</p>
                    <div class="code-block">
# Las t√©cnicas son m√©todos intercambiables
techniques = [
    self.naked_singles,
    self.hidden_singles, 
    self.naked_pairs,
    self.pointing_pairs
]
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">State Pattern (Patr√≥n Estado)</div>
                    <p>El solver mantiene y gestiona el estado completo del puzzle (grid + candidatos) y puede restaurarlo durante backtracking.</p>
                </div>
                
                <div class="method-card">
                    <div class="method-name">Template Method (M√©todo Plantilla)</div>
                    <p>El m√©todo <code>solve()</code> define el algoritmo general, delegando pasos espec√≠ficos a m√©todos especializados.</p>
                </div>
            </div>
            
            <div class="section">
                <h4>üìä Estructuras de Datos</h4>
                
                <table class="complexity-table">
                    <tr>
                        <th>Estructura</th>
                        <th>Tipo</th>
                        <th>Prop√≥sito</th>
                        <th>Complejidad Acceso</th>
                    </tr>
                    <tr>
                        <td>self.grid</td>
                        <td>NumPy Array (9x9)</td>
                        <td>Estado actual del Sudoku</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>self.candidates</td>
                        <td>Dict[(int,int): Set[int]]</td>
                        <td>Candidatos por posici√≥n</td>
                        <td>O(1) promedio</td>
                    </tr>
                    <tr>
                        <td>used_numbers</td>
                        <td>Set[int]</td>
                        <td>N√∫meros usados temporalmente</td>
                        <td>O(1) promedio</td>
                    </tr>
                    <tr>
                        <td>pairs (en naked_pairs)</td>
                        <td>DefaultDict[FrozenSet: List]</td>
                        <td>Agrupaci√≥n de parejas</td>
                        <td>O(1) promedio</td>
                    </tr>
                </table>
            </div>
            
            <div class="section">
                <h4>üßÆ An√°lisis de Complejidad Detallado</h4>
                
                <div class="method-card">
                    <div class="method-name">get_candidates(row, col)</div>
                    <div class="method-params">Complejidad: O(1) - Constante</div>
                    <p><strong>An√°lisis:</strong> Accede a arrays de tama√±o fijo (9 elementos), no depende del input.</p>
                    <div class="code-block">
# Operaciones de complejidad constante:
- grid[row, :] ‚Üí O(9) = O(1)  
- grid[:, col] ‚Üí O(9) = O(1)
- grid[box_slice] ‚Üí O(9) = O(1)
- set operations ‚Üí O(9) = O(1)
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">naked_singles()</div>
                    <div class="method-params">Complejidad: O(n) donde n = celdas_vac√≠as</div>
                    <p><strong>An√°lisis:</strong> Itera sobre candidatos una vez, operaciones internas son O(1).</p>
                </div>
                
                <div class="method-card">
                    <div class="method-name">hidden_singles()</div>
                    <div class="method-params">Complejidad: O(n¬≤) - Cuadr√°tica</div>
                    <p><strong>An√°lisis:</strong> Triple bucle anidado: 9 filas √ó 9 n√∫meros √ó m√°ximo 9 celdas</p>
                    <div class="code-block">
for row in range(9):           # 9 iteraciones
    for num in range(1, 10):   # 9 iteraciones  
        for col in range(9):   # m√°ximo 9 iteraciones
            # ‚Üí 9 √ó 9 √ó 9 = 729 = O(1) para Sudoku
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">naked_pairs()</div>
                    <div class="method-params">Complejidad: O(n¬≥) - C√∫bica</div>
                    <p><strong>An√°lisis:</strong> La m√°s costosa computacionalmente debido a comparaciones m√∫ltiples.</p>
                </div>
            </div>
            
            <div class="section">
                <h4>üîç Optimizaciones Espec√≠ficas del C√≥digo</h4>
                
                <div class="method-card">
                    <div class="method-name">1. Uso de Sets para Candidatos</div>
                    <p>Los conjuntos (Set) permiten operaciones matem√°ticas eficientes:</p>
                    <div class="code-block">
# Intersecci√≥n y diferencia en O(1) promedio
candidates = all_numbers - used_numbers
candidates.discard(number)  # O(1)
candidates -= pair_set      # O(min(len(candidates), len(pair_set)))
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">2. Actualizaci√≥n Incremental</div>
                    <p>En lugar de recalcular todo, actualiza solo lo necesario:</p>
                    <div class="code-block">
# Despu√©s de colocar un n√∫mero, solo actualiza celdas afectadas
def update_candidates_after_placement(self, row, col, num):
    # Solo elimina de fila, columna y caja - no recalcula todo
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">3. Detecci√≥n Temprana de Progreso</div>
                    <p>Cada t√©cnica retorna si hizo cambios, evitando iteraciones innecesarias:</p>
                    <div class="code-block">
while True:
    progress = False
    progress |= self.naked_singles()
    progress |= self.hidden_singles()
    if not progress:
        break  # Sale inmediatamente si no hay cambios
                    </div>
                </div>
                
                <div class="method-card">
                    <div class="method-name">4. Heur√≠stica MRV en Backtracking</div>
                    <p>Selecciona la celda m√°s restrictiva primero:</p>
                    <div class="code-block">
# Encuentra celda con menos opciones ‚Üí mayor probabilidad de √©xito/fallo r√°pido
min_candidates = min(len(cands) for cands in self.candidates.values())
# Reduce dram√°ticamente el factor de ramificaci√≥n
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h4>‚ö° Casos de Rendimiento</h4>
                
                <div class="info">
                    <strong>üöÄ Mejor Caso:</strong> Puzzle resuelto completamente con t√©cnicas l√≥gicas
                    <br><strong>Complejidad:</strong> O(k √ó n¬≤) donde k = n√∫mero de iteraciones (t√≠picamente 2-10)
                </div>
                
                <div class="warning">
                    <strong>üêå Peor Caso:</strong> Muy pocas celdas resueltas por l√≥gica, backtracking extensivo
                    <br><strong>Complejidad:</strong> O(9^m) donde m = celdas sin resolver por l√≥gica
                </div>
                
                <div class="method-card">
                    <div class="method-name">Caso Promedio (Puzzles T√≠picos)</div>
                    <p>Las t√©cnicas l√≥gicas resuelven 60-80% de las celdas, dejando 10-15 para backtracking.</p>
                    <p><strong>Tiempo esperado:</strong> < 1 segundo para la mayor√≠a de puzzles v√°lidos</p>
                </div>
            </div>
            
            <div class="section">
                <h4>üîß Posibles Mejoras y Extensiones</h4>
                
                <div class="method-card">
                    <div class="method-name">T√©cnicas L√≥gicas Adicionales</div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Hidden Pairs/Triples:</strong> Generalizaciones de Naked Pairs</li>
                        <li><strong>X-Wing:</strong> Patrones rectangulares en filas/columnas</li>
                        <li><strong>Swordfish:</strong> Extensi√≥n 3D del X-Wing</li>
                        <li><strong>XY-Wing:</strong> Cadenas de implicaci√≥n l√≥gica</li>
                    </ul>
                </div>
                
                <div class="method-card">
                    <div class="method-name">Optimizaciones de Rendimiento</div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Constraint Propagation:</strong> Propagaci√≥n m√°s agresiva de restricciones</li>
                        <li><strong>Look-ahead:</strong> Evaluaci√≥n de consecuencias antes de colocar n√∫meros</li>
                        <li><strong>Ordenamiento de Valores:</strong> Probar candidatos en orden de probabilidad</li>
                        <li><strong>Paralelizaci√≥n:</strong> Explorar m√∫ltiples ramas simult√°neamente</li>
                    </ul>
                </div>
                
                <div class="method-card">
                    <div class="method-name">Funcionalidades Adicionales</div>
                    <ul style="margin-left: 20px; margin-top: 10px;">
                        <li><strong>Validaci√≥n de Puzzles:</strong> Verificar si un puzzle tiene soluci√≥n √∫nica</li>
                        <li><strong>Generaci√≥n de Puzzles:</strong> Crear nuevos puzzles con dificultad espec√≠fica</li>
                        <li><strong>An√°lisis de Dificultad:</strong> Clasificar puzzles seg√∫n t√©cnicas requeridas</li>
                        <li><strong>Modo Paso a Paso:</strong> Mostrar cada t√©cnica aplicada interactivamente</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- Footer con informaci√≥n adicional -->
        <div class="section" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; text-align: center; border-left: none;">
            <h3><span class="icon">üéØ</span>Resumen Ejecutivo</h3>
            <p>Este solucionador representa una implementaci√≥n sofisticada que combina la elegancia de las t√©cnicas l√≥gicas humanas con la potencia computacional del backtracking optimizado. Su dise√±o modular permite extensiones futuras y su rendimiento es excelente para la gran mayor√≠a de puzzles de Sudoku encontrados en la pr√°ctica.</p>
            
            <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.3);">
                <strong>üìà Estad√≠sticas Clave:</strong><br>
                ‚úÖ 4 T√©cnicas L√≥gicas Implementadas<br>
                ‚úÖ Backtracking con Heur√≠stica MRV<br>
                ‚úÖ Complejidad Optimizada O(k√ón¬≤) en caso t√≠pico<br>
                ‚úÖ Interfaz de Depuraci√≥n Completa
            </div>
        </div>
    </div>
    
    <script>
        function showTab(tabName) {
            // Ocultar todos los contenidos
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => {
                content.classList.remove('active');
            });
            
            // Remover clase active de todas las pesta√±as
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Mostrar el contenido seleccionado
            document.getElementById(tabName).classList.add('active');
            
            // Activar la pesta√±a clickeada
            event.target.classList.add('active');
        }
        
        function toggleCollapsible(element) {
            const content = element.nextElementSibling;
            const isActive = content.classList.contains('active');
            
            if (isActive) {
                content.classList.remove('active');
                element.innerHTML = element.innerHTML.replace('‚ñ≤', '‚ñº');
            } else {
                content.classList.add('active');
                element.innerHTML = element.innerHTML.replace('‚ñº', '‚ñ≤');
            }
        }
        
        // Efectos de hover y animaciones adicionales
        document.addEventListener('DOMContentLoaded', function() {
            // A√±adir efectos de hover a las tarjetas de m√©todos
            const methodCards = document.querySelectorAll('.method-card');
            methodCards.forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-3px)';
                    this.style.boxShadow = '0 10px 20px rgba(0, 0, 0, 0.15)';
                });
                
                card.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.07)';
                });
            });
            
            // Efecto de escritura para el c√≥digo
            const codeBlocks = document.querySelectorAll('.code-block');
            codeBlocks.forEach(block => {
                block.addEventListener('mouseenter', function() {
                    this.style.background = '#34495e';
                    this.style.transition = 'background 0.3s ease';
                });
                
                block.addEventListener('mouseleave', function() {
                    this.style.background = '#2c3e50';
                });
            });
        });
    </script>
</body>
</html>